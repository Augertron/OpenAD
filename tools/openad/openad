#! /usr/bin/env perl
# -*-Mode: perl;-*-

# make sure we execute perl
#eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
#& eval 'exec perl -S $0 $argv:q'
#if 0;

# $Header: /m_home/m_utkej/Argonne/cvs2svn/cvs/OpenAD/tools/openad/openad,v 1.12 2004-09-30 16:49:13 eraxxon Exp $
## * BeginCopyright *********************************************************
## 
## 
## *********************************************************** EndCopyright *

#############################################################################
##
## $Source: /m_home/m_utkej/Argonne/cvs2svn/cvs/OpenAD/tools/openad/openad,v $ 
##
##   Nathan Tallent.
##
#############################################################################

use strict;
use warnings;

use FindBin qw($Script $RealBin);
use File::Spec;
use IO::File;
use Getopt::Long;

use lib "$RealBin/../libperltk";
use RunCmds qw(%CmdDesc RunCmds RunCmd);

STDOUT->autoflush(1); 

#############################################################################

my $the_program = $Script;
my $the_usage = 
"usage: ${the_program} [mode] [options] <fortran-file>

Mode:
  --bb-rev          BasicBlockPreaccumulationReverse [Default]
  --bb-tapeadj      BasicBlockPreaccumulationTapeAdjoint
  --bb-tape         BasicBlockPreaccumulationTape
  --bb              BasicBlockPreaccumulation
  --cfr             ControlFlowReversal
  --linear          Linearization
  --memopstradeoff  MemOpsTradeoffPreaccumulation

xaif2whirl [Temporary options]
  --x2w-structured    Use structured-CFG algorithm [Default]
  --x2w-unstructured  Use unstructured CFG algorithm
  --x2w-bb            Use BB patching algorithm (only for forward mode!)
  
General options:
  -v [lvl], --verbose [lvl]
    Set verbosity level.  If no level is supplied, defaults to 2.
    0: Play the silent game
    1: Pouty (terse message)
    2: Sanguine (standard activity messages) [Default]
    3: Chatty
    4: Talk your ear off
  -h, --help         print help

Development options:
  -n, --normalize 
    normalize away timestamps to ease output comparison with 'diff'
  -i, --interactive  
    prompt user to authorize each step in pipeline

\n";

my @the_options = ('bb-rev',
		   'bb-tapeadj',
		   'bb-tape',
		   'bb',
		   'cfr',
		   'linear',
		   'memopstradeoff',
		   
		   'x2w-structured',
		   'x2w-unstructured',
		   'x2w-bb',
		   
		   'verbose|v:i',
		   'help|h', 
		   
		   'interactive|i',
		   'normalize|n',
		   );

#############################################################################

my %xbModeType = ('BBReverse'      => 1,
		  'BBTapeAdjoint'  => 2,
		  'BBTape'         => 3,
		  'BB'             => 4,
		  'CFR'            => 5,
		  'Linearization'  => 6,
		  'MemOpsTradeoff' => 7,
		  );

my %x2wModeType = ('structured'   => 1,
		   'unstructured' => 2,
		   'bb'           => 3,
		   );

my %VerboseType = ('silent'    => 0,
		   'terse'     => 1,
		   'normal'    => 2,
		   'chatty'    => 3,
		   'teengirls' => 4,
		   );

my $shortCircuitExitVal = 42;

#############################################################################
## main/driver
#############################################################################

my $opt_verbose = undef;
my $opt_normalize = undef;
my $opt_interactive = undef;
#my $opt_debug = 0;

my $openad_mode = undef;
my $openad_x2w_mode = undef;
my $openad_input = undef;

# ----------------------------------------------------------
# Parse the command line
# ----------------------------------------------------------

parseCmdLine($0);

# ----------------------------------------------------------
# Run
# ----------------------------------------------------------

RunOpenADPipeline($openad_mode, $openad_input);


##############################################################################
## parseCmdLine
#############################################################################

sub parseCmdLine
{
  my ($command) = @_;
  
  # Get optional arguments
  my %opts = ();
  my $ret = GetOptions(\%opts, @the_options);
  if (!$ret) { 
    printErrorAndExit(); 
  }

  # Get optional arguments: verbose, help
  $opt_verbose = $VerboseType{normal}; # default
  if (defined($opts{'verbose'})) {
    $opt_verbose = $opts{'verbose'};
  } 
  if (defined($opts{'help'})) {
    printUsageAndExit($the_program);
  } 
  
  # Get required argument: OpenAD Mode
  $openad_mode = $xbModeType{BBReverse}; # default
  if (defined($opts{'bb-rev'})) {
    $openad_mode = $xbModeType{BBReverse};
  } 
  if (defined($opts{'bb-tapeadj'})) {
    $openad_mode = $xbModeType{BBTapeAdjoint};
  } 
  if (defined($opts{'bb-tape'})) {
    $openad_mode = $xbModeType{BBTape};
  } 
  if (defined($opts{'bb'})) {
    $openad_mode = $xbModeType{BB};
  } 
  if (defined($opts{'cfr'})) {
    $openad_mode = $xbModeType{CFR};
  } 
  if (defined($opts{'linear'})) {
    $openad_mode = $xbModeType{Linearization};
  } 
  if (defined($opts{'memopstradeoff'})) {
    $openad_mode = $xbModeType{MemOpsTradeoff};
  } 
  if (!defined($openad_mode)) {
    printUsageAndExit($the_program);
  }
  
  # Get optional arguments: OpenAD xaif2whirl mode
  $openad_x2w_mode = $x2wModeType{structured}; # default
  if (defined($opts{'x2w-structured'})) {
    $openad_x2w_mode = $x2wModeType{structured};
  } 
  if (defined($opts{'x2w-unstructured'})) {
    $openad_x2w_mode = $x2wModeType{unstructured};
  } 
  if (defined($opts{'x2w-bb'})) {
    $openad_x2w_mode = $x2wModeType{bb};
  } 
  
  # Get optional arguments: normalize, interactive
  if (defined($opts{'normalize'})) {
    $opt_normalize = 1;
  } 
  if (defined($opts{'interactive'})) {
    $opt_interactive = 1;
  } 
  
  # ----------------------------------------------------------
  # Required arguments
  # ----------------------------------------------------------

  my $numArgs = scalar(@ARGV);
  if ($numArgs != 1) { 
    printErrorAndExit("Invalid number of required arguments!\n"); 
  }
  
  $openad_input = $ARGV[0];
}

# printUsageAndExit
sub printUsageAndExit 
{
  my ($command) = @_; # not used now
  print STDOUT ${the_usage};
  exit(-1);
}

# printErrorAndExit
sub printErrorAndExit 
{
  my ($msg) = @_;
  if (defined($msg)) {
    print STDOUT "${msg}";
  }
  print STDOUT "Try `${the_program} --help' for more information.\n";
  exit(-1);
}

# printUsageAndExit
sub undefEnvVarErr 
{
  my ($var) = @_;
  print STDOUT "Undefined environment variable '${var}'\n";
  exit(-1);
}


#############################################################################
## Subroutines
#############################################################################

# RunOpenADPipeline:
{
  my $configured = undef;
  my ($MFEF90, $WHIRL2F) = (undef, undef);
  my ($W2X, $X2W, $NORM, $PP) = (undef, undef, undef, undef);
  my ($XB) = (undef);
  
  my ($OPENADFORTTK, $PLATFORM, $OPEN64) = (undef, undef, undef);
  my $XAIFBOOSTERROOT = undef;
  my $XAIFSCHEMAROOT = undef;
  
  my $f_RE = undef;
  my $F_RE = undef;
  my $f90_RE = undef;

  sub RunOpenADPipeline 
  {
    my($mode, $fortranfile) = @_;
    
    # Use this instead of a BEGIN block so we can pass options
    if (!defined($configured)) {
      ConfigRunOpenADPipeline($mode);
    }
    
    # Find base name of file. Support following extensions: .f90, .f, .F
    my $base = $fortranfile;
    my $num = ($base =~ s/(?:$f90_RE)|(?:$f_RE)|(?:$F_RE)//); 
    if ($num == 0) {
      print STDOUT "Unknown file type: ${fortranfile}\n";
      exit(-1);
    }

    #print STDOUT "$XB\n";
    # Will have to do this after some preprocessing...
    my $x2w_opt = "";
    my $pp_opt = "";
    if ($openad_mode == $xbModeType{BB} 
	|| $openad_mode == $xbModeType{Linearization} 
	|| $openad_mode == $xbModeType{MemOpsTradeoff}) {
      $x2w_opt .= " --mode=forward";
      $pp_opt .= " -f";
    }
    elsif ($openad_mode == $xbModeType{BBReverse} 
	   || $openad_mode == $xbModeType{BBTapeAdjoint}
	   || $openad_mode == $xbModeType{BBTape} 
	   || $openad_mode == $xbModeType{CFR}) {
      $x2w_opt .= " --mode=reverse";
    }
    
    if ($openad_x2w_mode == $x2wModeType{structured}) {
      $x2w_opt .= " --structured";
    } 
    elsif ($openad_x2w_mode == $x2wModeType{unstructured}) {
      $x2w_opt .= " --unstructured";
    } 
    elsif ($openad_x2w_mode == $x2wModeType{bb}) {
      $x2w_opt .= " --bb";
    }
    
    # Generate commands for pipeline.  Quote all files since these commands
    # will be passed to system().
    my $cmdDescVecRef = [ ];
    
    my $desc = { %RunCmds::CmdDesc, }; 
    $desc->{cmd} = "$MFEF90 -F -N132 '${fortranfile}'";
    $desc->{desc} = "Fortran to WHIRL: '${fortranfile}' -> '${base}.B'";
    push @{$cmdDescVecRef}, $desc;
    
    $desc = { %RunCmds::CmdDesc, }; 
    $desc->{cmd} = "$W2X '${base}.B' -o '${base}.xaif'";
    $desc->{desc} = "WHIRL to XAIF: '${base}.B' -> '${base}.xaif'";
    push @{$cmdDescVecRef}, $desc;

    if ($opt_normalize) {
      $desc = { %RunCmds::CmdDesc, }; 
      $desc->{cmd} = "$NORM '${base}.xaif'";
      $desc->{desc} = "Normalize XAIF: '${base}.xaif'";
      push @{$cmdDescVecRef}, $desc;
    }
    
    $desc = { %RunCmds::CmdDesc, }; 
    $desc->{cmd} = "$XB -i '${base}.xaif' -o '${base}.xb.xaif'";
    $desc->{desc} = "xaifBooster: '${base}.xaif' -> '${base}.xb.xaif'";
    push @{$cmdDescVecRef}, $desc;
    
    $desc = { %RunCmds::CmdDesc, }; 
    $desc->{cmd} = "$X2W $x2w_opt '${base}.B' '${base}.xb.xaif' -o '${base}.xb.x2w.B'";
    $desc->{desc} = "XAIF to WHIRL: ('${base}.B' '${base}.xb.xaif') -> '${base}.xb.x2w.B'";
    push @{$cmdDescVecRef}, $desc;

    $desc = { %RunCmds::CmdDesc, }; 
    $desc->{cmd} = "$WHIRL2F -openad '${base}.xb.x2w.B'";
    $desc->{desc} = "WHIRL to Fortran: '${base}.xb.x2w.B' -> '${base}.xb.x2w.w2f.f'";
    push @{$cmdDescVecRef}, $desc;

    if ($opt_normalize) {
      $desc = { %RunCmds::CmdDesc, }; 
      $desc->{cmd} = "$NORM '${base}.xb.x2w.w2f.f'";
      $desc->{desc} = "Normalize Fortran: '${base}.xb.x2w.w2f.f'";
      push @{$cmdDescVecRef}, $desc;
    }
    
    $desc = { %RunCmds::CmdDesc, }; 
    $desc->{cmd} = "$PP $pp_opt '${base}.xb.x2w.w2f.f'";
    $desc->{desc} = "Postprocess Fortran: '${base}.xb.x2w.w2f.f' -> '${base}.xb.x2w.w2f.pp.f'";
    push @{$cmdDescVecRef}, $desc;
    
    my $verb = $opt_verbose - $VerboseType{terse}; # normal goes to 1

    RunCmds($cmdDescVecRef, $verb, $opt_interactive);

    if ($opt_verbose >= $VerboseType{normal}) {
      print STDOUT "\n";
    }

    if ($opt_verbose >= $VerboseType{terse}) {
      print STDOUT "OpenAD: '${fortranfile}' --> '${base}.xb.x2w.w2f.pp.f'\n";
    }
  }

  sub ConfigRunOpenADPipeline 
  {
    my($mode) = @_;
    
    $OPENADFORTTK = $ENV{OPENADFORTTK};
    if (!defined($OPENADFORTTK)) { undefEnvVarErr('OPENADFORTTK'); }
    
    $PLATFORM = $ENV{OPENADFORTTK_PLATFORM};
    if (!defined($PLATFORM)) { undefEnvVarErr('OPENADFORTTK_PLATFORM'); }
    
    $OPEN64 = $ENV{OPENADFORTTK_OPEN64};
    if (!defined($OPEN64)) { undefEnvVarErr('OPENADFORTTK_OPEN64'); }
    
    $XAIFBOOSTERROOT = $ENV{XAIFBOOSTERROOT};
    if (!defined($XAIFBOOSTERROOT)) { undefEnvVarErr('XAIFBOOSTERROOT'); }
    
    $XAIFSCHEMAROOT = $ENV{XAIFSCHEMAROOT};
    if (!defined($XAIFSCHEMAROOT)) { undefEnvVarErr('XAIFSCHEMAROOT'); }
    
    $MFEF90  = "${OPEN64}/crayf90/sgi/mfef90";
    $WHIRL2F = "${OPEN64}/whirl2f/whirl2f";
    
    $W2X  = "${OPENADFORTTK}/obj/${PLATFORM}/obj/whirl2xaif";
    $X2W  = "${OPENADFORTTK}/obj/${PLATFORM}/obj/xaif2whirl";
    $NORM = "${OPENADFORTTK}/test/util/normalize";
    $PP   = "perl ${OPENADFORTTK}/postprocess/pp.pl";
    
    my $XB_alg_path = "${XAIFBOOSTERROOT}/xaifBooster/algorithms";
    my $XB_alg = undef;
    if ($mode == $xbModeType{BBReverse}) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulationReverse/test/t";
    } 
    elsif ($mode == $xbModeType{BBTapeAdjoint}) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulationTapeAdjoint/test/t";
    } 
    elsif ($mode == $xbModeType{BBTape}) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulationTape/test/t";
    }
    elsif ($mode == $xbModeType{BB}) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulation/test/t";
    }
    elsif ($mode == $xbModeType{CFR}) {
      $XB_alg = "${XB_alg_path}/ControlFlowReversal/test/t";
    }
    elsif ($mode == $xbModeType{Linearization}) {
      $XB_alg = "${XB_alg_path}/Linearization/test/t";
    }
    elsif ($mode == $xbModeType{MemOpsTradeoff}) {
      $XB_alg = "${XB_alg_path}/MemOpsTradeoffPreaccumulation/test/t";
    } 
    else {
      printErrorAndExit("Internal Error: invalid algorithm");
    }
    
    my $ii_xaif = "$XAIFSCHEMAROOT/schema/examples/inlinable_intrinsics.xaif";
    if ($PLATFORM eq "i686-Cygwin") {
      # convert to Windows path for XercesC
      $ii_xaif = "\`cygpath -w ${ii_xaif}\`";
    } 
    
    $XB = "${XB_alg} -c ${ii_xaif}";
    
    $f_RE = '.f$';
    $F_RE = '.F$';
    $f90_RE = '.f90$';

    ConfigSchema();
    ConfigPPFiles();
    
    $configured = 1;
  }

  sub ConfigSchema 
  {
    # Check if files already exist

    # FIXME: we should do this individually!

    my @schemafiles = glob("xaif*.xsd");
    if (scalar(@schemafiles) > 0) {
      return;
    }
    
    @schemafiles = glob("${XAIFSCHEMAROOT}/schema/xaif*.xsd");
    LinkFiles(\@schemafiles);
  }

  sub ConfigPPFiles
  {
    my $pfx = "${XAIFBOOSTERROOT}/xaifBooster/testRoundTrip";
    my @ppfiles = ();
    
    # Check if files already exist
    if (! -e './ad_inline.f') {
      push(@ppfiles, "${pfx}/ad_inline.f");
    }
    if (! -e './ad_template.f') {
      # FIXME: TMP HACK
      #push(@ppfiles, "${pfx}/simple.ad_template_split.f"); --> "ad_template.f"
      
      my $src = "${pfx}/simple.ad_template_split.f";
      my $dst = './ad_template.f';
      if (${PLATFORM} eq "i686-Cygwin") {
	link($src, $dst) or die "Error: could not link $src";
      } else {
	symlink($src, $dst) or die "Error: could not link $src";
      }
    }
    
    LinkFiles(\@ppfiles);
  }


  sub LinkFiles
  {
    my ($pathnmsRef) = @_;
    for my $path (@{$pathnmsRef}) {
      my ($vol,$dir,$file) = File::Spec->splitpath($path);
      if (${PLATFORM} eq "i686-Cygwin") {
	link($path, "./$file") or die "Error: could not link $path";
      } else {
	symlink($path, "./$file") or die "Error: could not link $path";
      }
    }
  }

}



# add a SHELL=/bin/sh


#############################################################################
## Generate Makefile commands
#############################################################################

# genSetVar: Given a variable name and value, generate a makefile
#   command to set the variable
# returns: a string
# effect: nothing
# assumes: nothing
sub genSetVar
{
  my($var, $value) = @_;
  
  if (!defined($value)) { 
    $value = '';
  }
  
  my $str = "${var}=${value}\n";
  return $str;
}


# genRule: Given a target string, a prerequisite string, a reference
#   to a list of commands (or a string with a command; or undef) and
#   whether target is PHONY or not, generate a makefile rule and return
#   the string.
# returns: a string
# effect: nothing
# assumes: nothing
sub genRule
{
  my($target, $prereq, $cmds, $phony) = @_;

  # Set up arguments
  if (!defined($phony)) {
    $phony = 0;
  }

  # Generate rule
  my $str = "${target} : ${prereq}\n";
  if (defined($cmds)) {
    if (ref($cmds)) {
      for my $cmd (@{$cmds}) {
	$str .= "\t${cmd}\n";
      }
    } 
    else {
      $str .= "\t${cmds}\n";
    }
  }
  
  if ($phony) {
    $str .= ".PHONY : ${target}\n";
  }
  
  return $str;
}


# addCmdWrappers: ??? take a command and add interactive or verbose
#   wrappers around it
# returns: a string
# effect: nothing
# assumes: nothing
sub addCmdWrappers
{
  my($cmdDescRef, $verbose, $interactive) = @_;
  
  my $str = "";
  
  # Note: must allow for both verbose and interactive at the same time
  if ($verbose >= 1) {
    $str = cmdCat($str, "echo \"$cmdDescRef->{desc}\"");
  }
  if ($interactive) {
    $str = cmdCat($str, "echo \"Execute? '$cmdDescRef->{cmd}'\n...[Y/n]\n\"");
    $str = cmdCat($str, 'read ans');
    $str = cmdCat($str, 'if [ "$$ans" = "n" ] || [ "$$ans" = "N" ] ; then');
    $str = cmdCat($str, "exit $shortCircuitExitVal ; fi");
  }
  
  $str = cmdCat($str, "$cmdDescRef->{cmd}");
  $str = "@" . $str;
  
  return $str;
}


# cmdCat: Given two or more command strings, concatenate them together
#   to form one command string that will exectute in one shell (one line
#   of a command in makefile rule)
# returns: a string
# effect: nothing
# assumes: nothing
sub cmdCat
{
  my(@cmds) = @_;
  
  my($re1) = qr/^\t/;
  my($re2) = qr/\n$/;

  my $str = "";
  for my $cmd (@cmds) {
    
    next if (!$cmd);

    # strip off leading tab and ending newline
    $str =~ s/$re1//;
    $str =~ s/$re2//;

    # add a semicolon and a line-continue if appending to a non-empty str    
    if ($str) { 
      $str .= " ; \\\n";
    }
    $str .= "\t${cmd}\n";
  }
  
  return $str;
}


#############################################################################

# Local Variables:
# perl-indent-level: 2
# End:
