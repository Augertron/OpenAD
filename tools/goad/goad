#! /usr/bin/env perl
# -*-Mode: perl;-*-

# make sure we execute perl
#eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
#& eval 'exec perl -S $0 $argv:q'
#if 0;

# $Header: /m_home/m_utkej/Argonne/cvs2svn/cvs/OpenAD/tools/goad/goad,v 1.12 2004-09-28 19:57:28 eraxxon Exp $
## * BeginCopyright *********************************************************
## 
## 
## *********************************************************** EndCopyright *

#############################################################################
##
## $Source: /m_home/m_utkej/Argonne/cvs2svn/cvs/OpenAD/tools/goad/goad,v $ 
##
##   Nathan Tallent.
##
#############################################################################

use strict;
use warnings;

use FindBin qw($Script $RealBin);
use Cwd qw(cwd abs_path);
use IO::File;
use Getopt::Long;

use POSIX qw(strftime);

use lib "$RealBin/../libperl";
use RunCmds qw(%CmdDesc RunCmds RunCmd);

use lib "$RealBin/../..";
use openad_config;

my $OpenADRoot = abs_path("$RealBin/../..");

STDOUT->autoflush(1); 

#############################################################################

my $the_program = $Script;
my $the_usage = 
"usage: ${the_program} [options]

Get (or update) OpenAD repositories.  Requires cvs and bitkeeper.
  
Options:
  --skip-update  : do not update existing repositories; only get new ones
  --self-only    : update only OpenAD files; CVS environment must be set. 
                   This is useful when the OpenAD child repositories are
                   located within the OpenAD repository.

  -v [lvl], --verbose [lvl]
    Set verbosity level.  If no level is supplied, defaults to 2.
    0: Play the silent game
    1: Pouty (terse message)
    2: Sanguine (standard activity messages) [Default]
    3: Chatty
    4: Talk your ear off
  -h, --help         print help

Development options:
  -i, --interactive  
    prompt user to authorize each command
\n";

# -d, --debug [lvl]  Debug level

my @the_options = ('skip-update',
		   'self-only',
		   
		   'verbose|v:i',
		   'help|h', 
		   'interactive|i',
		   'debug|d:i',
		   );

#############################################################################

#my %VerboseTypes = (
#		    "silent"    => 0,
#		    "terse"     => 1,
#		    "normal"    => 2,
#		    "chatty"    => 3,
#		    "teengirls" => 4,
#		    );

my ($mode_verb_silent,
    $mode_verb_terse,
    $mode_verb_normal,
    $mode_verb_chatty,
    $mode_verb_teengirls) =
    (0, 1, 2, 3, 4);

my $cvsSelfRepo = 
    [ 'bin', 'config', 'doc', 'test', 'tools',
      'Makefile*', 'openad_config.pm', 'README*', 'setenv.*' ];


#############################################################################
## main/driver
#############################################################################

my $opt_verbose = undef;
my $opt_interactive = undef;
my $opt_debug = 0;

my $opt_skipupdate = 0;
my $opt_selfonly = 0;


# ----------------------------------------------------------
# Parse the command line
# ----------------------------------------------------------

parseOptions($0);

# ----------------------------------------------------------
# Run
# ----------------------------------------------------------

my $config = openad_config->new();
my $opts = { 
  selfonly   => $opt_selfonly,
  skipupdate => $opt_skipupdate,
  verbose    => $opt_verbose - $mode_verb_terse, # normal goes to 1
  logfnm     => prepareLogFile(),
  debug      => $opt_debug,
};

print STDOUT "Sending output to '" . $opts->{logfnm} . "'\n";

RunRepositoryUpdate($OpenADRoot, $cvsSelfRepo, $config, $opts);

exit(0);

#############################################################################
## parseOptions
#############################################################################

sub parseOptions
{
  my ($command) = @_;
  
  # Get optional arguments
  my %opts = ();
  my $ret = GetOptions(\%opts, @the_options);
  if (!$ret) { 
    printErrorAndExit(); 
  }
  
  # Get optional arguments: verbose, help
  $opt_verbose = $mode_verb_normal; # default
  if (defined($opts{'verbose'})) {
    $opt_verbose = $opts{'verbose'};
  } 
  if (defined($opts{'help'})) {
    printUsageAndExit($the_program);
  }
  if (defined($opts{'debug'})) {
    $opt_debug = $opts{'debug'};
  }
  
  # Get optional arguments: interactive
  if (defined($opts{'interactive'})) {
    $opt_interactive = 1;
  } 

  # Get optional arguments: skip-update
  if (defined($opts{'skip-update'})) {
    $opt_skipupdate = 1;
  } 
  if (defined($opts{'self-only'})) {
    $opt_selfonly = 1;
  } 

  
  # Get required arguments
  my $numArgs = scalar(@ARGV);
  if ($numArgs != 0) { 
    printErrorAndExit("Invalid number of required arguments!\n"); 
  }
}


# printUsageAndExit
sub printUsageAndExit 
{
  my ($command) = @_; # not used now
  print STDOUT ${the_usage};
  exit(-1);
}

# printErrorAndExit
sub printErrorAndExit 
{
  my ($msg) = @_;
  if (defined($msg)) {
    print STDOUT "${msg}";
  }
  print STDOUT "Try `${the_program} --help' for more information.\n";
  exit(-1);
}

# printUsageAndExit
sub undefEnvVarErr 
{
  my ($var) = @_;
  print STDOUT "Undefined environment variable '${var}'\n";
  exit(-1);
}


#############################################################################
## Subroutines
#############################################################################

# Returns the name of a log file that has size 0 in the filesystem.
sub prepareLogFile
{
  #my ($x) = @_;

  my $dir = cwd();
  my $stamp = strftime("%Y_%m_%d-%H_%M_%S", localtime(time()));
  my $logfnm = "${dir}/goad.${stamp}.log~";
  truncate($logfnm, 0);
  
  return $logfnm;
}


# RunRepositoryUpdate: Given several arguments, perform a get or
# update on a repository that itself contains other cvs or bitkeeper
# repositories.
#   selfRoot     - the root of the shell CVS repository
#   selfCVSFiles - list of shell globs representing the shell CVS repository
#   otherConfig  - config file defining other repository info
#   opts         - a hash of options
#     'selfonly'   - update only the shell repository (boolean)
#     'skipupdate' - do not update an existing repository (boolean)
#     'verbose'    - 0 (no), 1 (moderate) or 2 (extreme)
#     'logfnm'     - if defined, the name of a log file to which all output
#                    should be sent
#     'debug'      - if defined, a debug level from 0 - 9
sub RunRepositoryUpdate 
{
  my($selfRoot, $selfCVSFiles, $otherConfig, $opts) = @_;
  
  my $cmdDescVecRef = [ ];
  my $desc = undef;
  
  my $selfonly   = (defined($opts->{selfonly})) ? $opts->{selfonly} : 0;
  my $skipupdate = (defined($opts->{skipupdate})) ? $opts->{skipupdate} : 0;
  my $verbose    = (defined($opts->{verbose})) ? $opts->{verbose} : 0;
  my $debug      = (defined($opts->{debug})) ? $opts->{debug} : 0;

  # --------------------------------------------------------
  # Generate commands for self (always a cvs update)
  # --------------------------------------------------------

  if ($selfonly) {
    my $selfFiles = '';
    for my $x (@{$selfCVSFiles}) {
      $selfFiles .= ' ' . $x;
    }
    
    $desc = { %RunCmds::CmdDesc, };  
    $desc->{cmd} = "cd ${selfRoot} ; cvs update ${selfFiles}";
    $desc->{desc} = "cvs update ${selfRoot}";
    push(@{$cmdDescVecRef}, $desc); 
  }

  # --------------------------------------------------------
  # Generate commands for sub repositories
  # --------------------------------------------------------
  
  if (!$selfonly) {
    my $OpenADRepos = $otherConfig->getRepos();
  
    for my $repo (@{$OpenADRepos}) {
      
      # if we don't have repository info, then this is external to us
      next if (!defined($repo->{repos}));
      
      my $repoPath = $repo->{path} . '/' . $repo->{name};
      my $repoExists = (-d $repoPath);
      my $repoTag = (defined($repo->{tag})) ? $repo->{tag} : "default";
      #print("--> $repoPath\n");
      
      next if ($repoExists && $skipupdate);
      
      # Either checkout or update the repository
      $desc = { %RunCmds::CmdDesc, };
      
      if (defined($repo->{repos}->{iscvs})) {
	# A CVS repository
	my $nm = $repo->{name};
	my $env = 'CVS_RSH="' . $repo->{repos}->{rsh} . '"';
	my $opt = '-z5 -d ' . $repo->{repos}->{root};
	my $tag = $repoTag;
	
	if ($repoExists) {
	  $desc->{cmd} = "cd ${repoPath} ; ${env} cvs ${opt} update";
	  $desc->{desc} = "cvs update ${repoPath} (${tag})";
	}
	else {
	  my $coopt = (defined($repo->{tag})) ? "-r " . $tag : "";
	  $desc->{cmd} = "cd $repo->{path} ; ${env} cvs ${opt} co ${coopt} ${nm}";
	  $desc->{desc} = "cvs checkout ${repoPath} (${tag})";
	}
      } 
      elsif (defined($repo->{repos}->{isbk})) {
	# A BitKeeper repository
	my $nm = $repo->{name};
	my $arg = $repo->{repos}->{root};
	my $tag = $repoTag;
	
	if ($repoExists) {
	  $desc->{cmd} = "cd ${repoPath} ; bk pull";
	  $desc->{desc} = "bk pull ${repoPath} (${tag})";
	}
	else {
	  $desc->{cmd} = "cd $repo->{path} ; bk clone ${arg}";
	  $desc->{desc} = "bk clone ${repoPath} (${tag})";
	}
      }
      else {
	die "Programming Error!";
      }
      
      push(@{$cmdDescVecRef}, $desc);
    }
  }
  
  # --------------------------------------------------------
  # Run commands
  # --------------------------------------------------------
  if ($debug) {
    print STDOUT "--> ", $opts->{logfnm}, "\n";
  }

  RunCmds($cmdDescVecRef, $verbose, $opt_interactive, $opts->{logfnm});
}


#############################################################################

# Local Variables:
# perl-indent-level: 2
# End:
